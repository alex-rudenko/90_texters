() BASH 
http://wiki.bash-hackers.org/start

=============================================================================
ПЕРЕМЕННЫЕ

 <Переменные в кавычки !>

$# - общее количество параметров переданных скрипту
$* - все аргументы переданыне скрипту (выводятся в строку)
$@ - тоже самое, что и предыдущий, но параметры выводятся в столбик
$! - PID последнего запущенного в фоне процесса
$$ - PID самого скрипта or process ID of the shell
$? - exit status of the most recently executed foreground pipeline

${#var}  - длина строки var
var=$(ls) - substitution, присвоить var результат команды

bash -x      в режиме отладки

set -x       можно прописать в теле скрипта, это
  ...        отладка в скрипте, здесь в блоке кода все будет по шагам со значениями переменных
set +x

=============================================================================
TEST + ОПЕРАТОРЫ СРАВНЕНИЯ

test или [ ]   - старый способ, совместим с sh, то, что в скобках - как аргументы командной строки, поэтому возможны сюрпризы

[[ ]]   - bash extension, рекомендуемый в bash

СИНТАКСИС И ИСПОЛЬНОВАНИЕ
[[ переменная ]]			ПРОБЕЛЫ ЗНАЧАТ !!!!!!!!!!!
[[ -e filename ]]
[[ ! -d dirname ]]
[[ аргумент оператор аргумент2 ]]

ТОЛЬКО ЦЕЛОЧИСЛЕННАЯ АРИФМЕТИКА, для цифр операторы:
-eq
-ne
-lt
-gt

Для строк < > = и т.д.

! - NOT			[[ ! -d dir1 ]]
&& - AND                [[ $# -eq 1 && $1="foo" ]]
|| - OR                 [[ $a || $b ]]

НЕ ИСПОЛЬЗОВАТЬ -a -o для AND и OR !!! это старый стиль команды test и вероятны проблемы !!

help test
help [[

=============================================================================
IF

if [[ ]]; then
  ...
elif [[ ]]; then
  ...
  ...
else
  ...
fi

=============================================================================
INPUT / OUTPUT

echo "hello" вывод с переводом строки
echo -n "hello" без пеервода строки в конце вывода
echo -e разрешается использовать некоторые ESC sequences !!! NON PORTABLE to NON BASH SHELLS
  \t  tab  не использовать...
  \b  backspace  не использовать...

printf лучше для сложного форматирования, не переводит строку
printf "hello"
printf "hello\n"  аналог echo

-----------------------------------------------
printf "hello %s, how are you?" $USER
               ^                  ^
             string     ->    this string  
-----------------------------------------------
printf "p%st\n" a e i o u          тут аргументов больше, чем надо, произойдет вывод по каждому :)
pat
pet
pit
pot
put
-----------------------------------------------
printf "%ss home is %s" $USER $HOME
rudenkos home is /home/rudenko
-----------------------------------------------
printf "|%20s |%20s |%20s |\n" $(ls)   вывести ls в 3 столбца по 20 символов шириной и с разделителями |
-----------------------------------------------
printf -v greeting "hello %s, how are you?\n" $USER  присвоить все переменной greeting
-----------------------------------------------
line="-=0=-"
printf "$line\n"        !!! выдаст ошибку, т.к. посчитает - за параметр команды !!!
printf"%s\n" "$line"    все ок, ТАК БЕЗОПАСНО, ДЕЛАЕМ ТАК !
-----------------------------------------------

read x   считать в переменную x
read     считается в спец переменную REPLY
read -n  считаль n символов (вообще, вроде как -n читает до \n, а -N ровно столько символов, сколько указал, но у меня работает одинаково)
read -s  не будет выводить, что печатаю, для паролей
!!! read -r  запрещает ESC sequences, что нам желательно, на самом деле, что запретит странный ввод
!!! ИСПОЛЬЗУЕМ -r
read x y разные слова в разные переменные read "1 2 3" => x=1 y="2 3" использует IFS (переменная среды!!!!) в качестве разделителей, можно определить свои
read -p "What is your name ? " name            выведет текст, сохранит ввод в переменную

-----------------------------------------------
0 standard input (stdin)
  /dev/stdin
1 standard out (stdout)
  /dev/stdout
2 standard error (stderr)
  /dev/stderr
  
<       input redirection
>, >>   output redirection
|       pipe 

N>                      redirect stream N (по умолчанию - 1, его писать не надо, если перенаправляем !)
cmd 2> /dev/null        перенаправить ошибки в null
cmd >                   перенапрамить stdout
>&2                     перенаправить stdout в stderr (не 1>&2 т.к. 1=по умалчанию)
2>&1                    перенаправить ошимки в стандартный вывод

cmd > logfile 2>&1      вывод команды и ошибок в logfile
НЕ ИСПОЛЬЗОВАТЬ cmd > logfile 2> logfile, одно перетрет другое
НЕ ИСПОЛЬЗОВАТЬ &> or >& т.к. устарели в смысле речь о cmd &> logfile

!!! ПОРЯДОК ИММЕТ ЗНАЧЕНИЕ !!!

cmd < inputfile > outputfile   АНАЛОГИЧНО   > outputfile cmd < inputfile
НО !!!

cmd>logfile 2>&1      здесь ошибки попадут в лог
2>&1 >logfile cmd     здесь ошибки попадут на экран

-----------------------------------------------
WHILE работает пока тест возвращает TRUE !!

while [[ ]]; do
  ...            код в цикле
done

-----------------------------------------------
UNTIL работает пока тест возвращает FALSE !!

until [[]]; do
  ...
done

-----------------------------------------------
FOR classic version

for VAR in WORDS; do     тут имя переменной, без $... мы хотим разделить слова, не используем ""
  ...
done

for i int Some words here; do echo $i; done
Some
words
here

str1="list of words"
for i in str1; do echo $i; done - выведет по словам
for i in "str1"; do echo $i; done - выведет строкой... вот это имелось в виду по поводу кавычек

for i in *.txt; do cat "$i"; done   - просто пример

!! best practice !!
for i in *.del; do echo rm "$i"; done  -  !!! ДЛЯ ОТЛАДКИ ЧАСТО ПЕРЕД РЕАЛЬНОЙ КОМАНДОЙ СТАВЯТ echo !!!

-----------------------------------------------
FOR C-style

for (( INIT; TEST; UPDATE )); do
  ...
done


for (( i=0; i<10; ++i )); do
  echo $i
done

-----------------------------------------------
BREAK / CONTINUE

break		quits the loop
continue	skips the rest of the current - moves to the next iteration

-----------------------------------------------
CASE

case WORD in
  PATTERN1)
    code1;;    не забываем про ;; в конце блока кода
  PATTERN2)
    code2;;
  ...
  PATTERNn)
    coden;;
esac

-----------------------------------------------
{} && ||

{group of commands}		группирует команды для, например, перенаправления
{ cmd1; cmd2; cmd3; }		синтаксис

&&			исполнять, если предыдущая успешна
mkdir 111 && cd 111

||			исполнять, если предыдущая неудачна
[[ $1 ]] || echo "missing argument" >&2

!!! ВНИМАТЕЛЬНО С ГРУППИРОВКОЙ !!!
[[ $1 ]] || echo "missing argument" >&2 && exit 1    !!! этот код в любом случае будет выпадать в exit !!!
[[ $1 ]] || { echo "missing argument" >&2; exit 1; }  так работает корректно

-----------------------------------------------
VARIABLES PART2

Переменным можно присвоить атрибуты, что даст другой смысл.

declare		можно задать тип
typeset		аналог, но устаревшее, только для совместимости

declare -p var  распечатать инфо про переменную

declare -i num    добавит атрибут integer, если присвоить ей строку, то !!! будет 0 !!!
                  !!! ЭТО ВАЖНО ПОМНИТЬ !!! ошибка не выведется
deсlare +i num    убрать integer atribute

p="4+5"		  позволяет выполнять операции с числами в упрощенном виде, см пример ниже
echo $p
4+5
declare -i p
p="4+5"
echo $p
9
p=test
echo $p
0		  не может содержать строки

-----------------------------------------------
АРИФМЕТИКА, C-like
let	(( ))	  $(( ))

let n=100/2			присвоение

((++x))				calculation
((p=x/100))
(( p=$(ls | wc -l)*10 ))

p=$((x/100))			substitution, это азмещение команды и просто так не используется,
				надо в команде типа не $((++x)) а echo $((++x))


declare -i num
num="30%8"			переменная с атрибутом integer, тут присвоится 6

No need to quote variables, but allowed...

(( )) в условиях или циклах 0 = FALSE, !0 = TRUE

declare -i p
p=010			!!! воспримет как восьмиричное, т.к. начинается с 0
echo $p
8

В цикле for (( ..; ..; .. )) в целом - не арифметическое выражение, но каждое из внутри - да

-----------------------------------------------
READ-ONLY VARIABLES

declare -r constant="some value"
Значение такой переменной изменить нельзя, если попытаеыся - баш выдаст ошибку.

-----------------------------------------------
EXPORTING VARIABLES

По умолчанию, переменные локальны в скрипте или терминале, в котором мы работаем.
Если необходимо сделать их доступными для подпроцессов - export.
В обратную сторону не работает - из подпроцесса нельзя в родительский передать.

export var			!!! СПОСОБЫ !!!
export var="value"
declare -x var="value"

! При экспорте атрибуты переменных НЕ !!! передаются !

Переменные окружения, экспорт перед выполнением скрипта :))) экспорт в дочерний !!
.bashrc (например)
NOTESDIR="${HOME}/home"

-----------------------------------------------
ARRAY

Задание массива
x[0]="some"
x[1]="word"
ar=(1 2 3 a b c)

declare -a x

Вывод элементов массива
${x[0]}
${x[*]} все элементы массива строкой
${x[@]} все элементы массива по одному

${#array[@]} общее количество элементов массива
${!array[@]} индексы массива, могут быть пробелы, типа 0 1 2 3 34 100 205

declare -p array ПРОСМОТРЕТЬ array в удобном виде !

root@client:~# no[1]=12
root@client:~# no[101]=55
root@client:~# no[99]=Ds
root@client:~# echo ${no[1]}
12
root@client:~# echo ${no[99]}
Ds
root@client:~# echo ${no[101]}
55
root@client:~# echo ${no[*]}
12 Ds 55
root@client:~# echo ${no[@]}
12 Ds 55
root@client:~# echo ${#no[@]}
3
root@client:~# echo ${!no[@]}
1 99 101
root@client:~# declare -p no
declare -a no='([1]="12" [99]="Ds" [101]="55")'


!!! МАССИВЫ НЕЛЬЗЯ ЭКСПОРТИРОВАТЬ, т.к. атрибуты слетают при экспорте !!!

!!! BASH 4 и позже => ASSOCIATIVE ARRAYS, но именам не по индексам... (хэш словари ??)
declare -A array   тут !!! А большая !!!

-----------------------------------------------
HANDLING SCRIPT PARAMETERS

$1 $2 ... ${10} ${11} ...	positional parameters, 10 и более в {}

$0				holds name of script AS IT WAS CALLED !!!
  !!! ТО ЕСТЬ, ЕСЛИ СОЗДАЛИ СИМЛИНК, ТО В $0 БУДЕТ ИМЯ СИМЛИНКА, А НЕ СМОГО СКРИПТА !!!
  !!! ТАК ЧАСТО ДЕЛАЮТ, ЧТОБЫ ЗАПУСТИТЬ ОДИН И ТОТ ЖЕ СКРИПТ ПО-РАЗНОМУ, опции там всякие и т.д. !!!

$@				все аргументы скрипта $1 $2 $3 $4 e.t.c.
  "$1" "$2" "$3" "$4"		в этом смысле, когда "$@", каждый арг в кавычках
  !!! ЭТО ВАЖНО, когда есть параметры из нескольких слов типа: script "option one" two three !!!

$*				все аргументы скрипта $1 $2 $3 $4 e.t.c.
  "$1 $2 $3 $4"			в этом смысле, когда "$*", одной строкой
  !!! НЕ ТО, ЧТО МЫ БЫ ХОТЕЛИ ПО УМОЛЧАНИЮ В БОЛЬШИНСТВЕ СЛУЧАЕВ !!! понимать зачем так делаем, если делаем...

$# 				количесво аргументов, без учета $0

+++ пример start +++
SCRIPT:
#!/bin/bash

for i int ПОДСТАНОВКА; do
  echo $a;
done
+++

ПОДСТАНОВКА = $@
SCRIPT "first arg" second third
first
arg
second
third

ПОДСТАНОВКА = $*
SCRIPT "first arg" second third
first
arg
second
third

ПОДСТАНОВКА = "$@"
SCRIPT "first arg" second third
first arg
second
third

ПОДСТАНОВКА = "$*"
SCRIPT "first arg" second third
first arg second third

+++ пример end +++

SHIFT  сдвигает аргументы скрипта
shift - убирает первый аргумент и перенумерует все остальные, !!! $# уменьшается на 1 !!!
$2 ->$1
$3 ->$2
$4 ->$3
...

shift 3 - убирает первые 3 аргумента, остальное по аналогии

GETOPTS  утилита для работы с опциями типа -х или -f filename
getopts optstring name
  optstring - список ожидаемых опций "ab" значит -a and/or -b
              если пишем "c:" то это опция типа -f filename со значением
              "a:b" значит опция a с аргументом, опция b без
  name имя переменной, в которую будет помещаться каждая последующая опция при вызове getopts
       $name соответственно, сожержит опцию

Обычно getopts вызывается в цикле, пока не закончатся аргументы.

+++ пример start +++

Ожидаемые опции:  -b цифра  |  -s цифра  |  -r 

while getopts "b:s:r" opt; do
  case $opt in
    r)
        reverse="yes"   #эта опция для реверса чего -то
        ;;
    b)
        [[ ${OPTARG} =~ ^[0-9]+$ ]] || { echo "${OPTARG} is not a number" >&2; exit 1; }
        start="${OPTARG}"    #если цифра, присвоим, иначе выход
        ;;
    s)
        [[ ${OPTARG} =~ ^[0-9]+$ ]] || { echo "${OPTARG} is not a number" >&2; exit 1; }
        step="${OPTARG}"    #если цифра, присвоим, иначе выход
        ;;
    \?)    #это любая не ожидаемая опция или отсутствие второй части для опций с параметром... выходим
        exit 1
        ;;
  esac
done
+++ пример stop +++

!!! {OPTARG} значение опции

!!! OPTIND holds the index of the next argument to be processed
!!! shift $(( OPTIND -1 )) убрать опции для последующей обработки остальных параметров

То есть: обработали опции, сдвинули аргументы, работаем с аргументами.

getops: handling errors
  default non-silent mode		автоматически обрабатывает и сообщает об ошибке
  обычно - не то, чего нам хочется, других сообщений
  "b:s:r"         тут в default non-silent

  silent mode       ":b:s:r"		!!! двоеточие перед первой опцией !!!
  мы сами обрабатываем ошибки
  при этом:
    неизвестная опция: имя опции будет ?, значение передастся в OPTARG
    отсутствующий аргумент опции: имя опции будет :, значение передастся в OPTARG

тогда обработка ошибок:
  case $opt in
    :)
        echo "Option -${OPTARG} is missing an argument"
        exit 1
        ;;
    \?)
        echo "Unknown option: -${OPTARG}" >&2
        exit 1
        ;;
  esac

-----------------------------------------------
FUNCTIONS

name () {...}
Старые способы: (не используем так для совместимости)
function name () {...}
function name {...}

Функции исполняются как нормальные команды, им можно давать аргументы, $1, $2 и т.д.
Можно перенаправлять ввод и вывод функций, все как обычно.
В этом смысле можно воспринимать функции, как скрипт внутри скрипта.
Необходимо правильно называть, чтобы не конфликтовать с тем, что есть.

+++ пример start +++
sum () {
   return $(( $1 + $2 ))
}
sum 4 5
echo $?			вывод функции, как return status... по мне как-то так не очень, хз
9
+++ пример stop +++


+++ пример start +++
sum () {
   echo $(( $1 + $2 ))
}
sum 4 5			сразу выведет в stdout
9
+++ пример stop +++


+++ пример start +++
sum () {
   echo $(( $1 + $2 ))
}
echo $(sum 4 5)		substitution
9
+++ пример stop +++


+++ пример start +++
check_eq_Aa () {
   [[ $1 == [Aa] ]]
   return $?		вернет результат последней команды, то есть теста на строку выше
}			тепрь можем использовать для другой логики
+++ пример stop +++

Можно сделать переменные, локальные в функции.
Для этого использовать declare илил local.

Выход из функции return (не exit, который выходит из всего скрипта)
Возвращает статус код, наподобие exit.
Если функция выходит без выражения return, то возвращается код последней команды.

Если необходимо, чтобы функция вернула текст или данные, то делаем это через глобальную переменную.
Также можно отправить вывод на output (stdout) и использовать commund substitution.

Функции можно экспортировать в subprocesses:
export -f name
Тогда функция доступна в дочерних процессах.

Хороший тон делать usage () {...} функцию. Это HERE DOCUMENTS.
usage () {
  cat <<END				здесь такое специальное перенаправление текста между маркерами END в cat			
     This in usage description...
  END
}

Пример перенаправления вывода функции в stderr:
error () {
  echo ...
  ...обработка ошибки...
  exit ...
} >&2		ПЕРЕНАПРАВЛЕНИЕ




!!! ВАЖНО !!! 

declare -i count=0
count_lines (){
  while read -r; do
    ((++count))
  done
}
ls | count_lines ()
echo $count

Хотели посчитать строки функцией, объявили глобальную переменную, вроде все сделали правильно.
НО т.к. вызвали через ПАЙП, count_lines исполнялась в дочернем процессе
и после выполнения значение переменной count потеряно !! работать не будет !!
!!!

mktemp 	    - сгенерировать темп файл для промежуточных результатов (где он будет... все зависит от системы) не забывать почистить потом rm
tput cols   - определить ширину окна терминала

!!! ТРЮК СОВМЕСТИМОСТИ !!!
{ du -d 0 */ || --max-depth 0 *; } 2>/dev/null 
Когда не знаем какая именно команда в нашем дистрибутиве:
пробуем одну - не прокатило - вторую... и херим ошибки !

-----------------------------------------------
STRINGS

Parameter expansion

${#var}		длина строки

! Удалить часть строки !
${var#pattern}	удалить часть переменной сначала, shortest match
${var##pattern}	удалить часть переменной сначала, longest match
${var%pattern}	удалить часть переменной с конца, shortest match
${var%%pattern}	удалить часть переменной с конца, shortest match

При этом pattern в смысле как подстановки для файлов, не как regexp !

+++ пример start +++

i="/home/rudenko/file.txt"

${i#*/}		home/rudenko/file.txt		здесь */ попадает в первый /
${i##*/}	file.txt			здесь все до последнего / включительно
${i%.*}         /home/rudenko/file		удалили разрешение
${i%/*}		/home/rudenko			удалили файл, оставили только путь
#{i%%/*}	ничего				уберет все с первого / включительно

+++ пример stop +++

! Замена в строке !

${var/pattern/string}	заменить первое совпадение
${var//pattern/string}	заменить все совпадения
${var/#pattern/string}	заменть вначале строки при совпадении с pattern
${var/%pattern/string}	заменить в конце строки при совпадении с pattern

+++ пример start +++

i="mytxt.txt"
echo ${i/txt/jpg}
myjpg.txt
echo ${i//txt/jpg}
myjpg.jpg
echo ${i//txt/}
my.
echo ${i/%txt/}		эквивалентно	echo ${i%txt}
mytxt.
echo ${i/#/txt/}
mytxt.txt
echo ${i/[yx]/a}
matxt.txt
echo ${i//[yx]/a}
matat.tat

+++ пример stop +++

!!! ЭТИ ШТУКИ (Parameter Expansion) ВСТРОЕНЫ В BASH, ОНИ БЫСТРЫЕ, ИСПОЛЬЗУЕМ !!!


! Default Values !

${var:-value}	дает value, если переменная пустая или не задана
${var-value}	дает value, ТОЛЬКО если переменная не задана
${var:=value}	присваивает значение value переменной, если она пустая или не задана
${var=value}	присваивает значение value переменной, ТОЛЬКО если она не задана

МНОГО ФУНКЦИОНАЛА В Parameter Expansion, читаем: http://goo.gl/xRHo3u
подстроки, индексы, регистр и т.д.

+++ пример start +++

declare notesdir="${HOME}"			переменная HOME встроенная, задаем ее по умолчанию
[[ $NOTESDIR ]] && notesdir="${NOTESDIR}"	если пользователь задал NOTESDIR, по override

Это можно заменить на:

declare notesdir="${NOTESDIR:-$HOME}"

+++ пример stop +++


== и !=   в   [[ ]] выполняют pattern matching (не string и не regexp)

!!!	Во - первых, == одно и то же, что = 	!!!

[[ $filename == *.txt ]]	отобрать *.txt файлы

!! НО !! КОГДА ИСПОЛЬЗУЕМ "" ТО STRING MATCHING
[[ $var == "[0-9]*" ]] ищет соответствие со строкой "[0-9]*" 		!!!!!!!!!!


+++ пример start +++

[[ hello = h*o ]] && echo yes
yes

[[ hello = "h*o" ]] && echo yes
не найдет

[ hello = h*o ] && echo yes
не найдет, т.к. это классический тест, и работает по - другому, он вообще файлы перебирать будет...
используем [[ ]], короче

+++ пример stop +++


REGEXP MATCHING

=~		оператор для regexp matching, самый мощный из всех
		работает по правилам regexp, ? значит 0 или 1 вхождение, не забываем...
		в общем все по правилам старых добрых regexp

Грамотное использование:
declare -r num_re='^[0-9]+$'		отлавливаем цифру, задали шаблон в переменной и потом сравниваем с переменной !!!
if [[ $1 =~ $num_re ]]; then ...	это позволит избежать проблем с экранированием...

BASH REMATCH - пример сразу

declare -r num_re='^[0-9]+$'
declare -r octal_re='^0(.+)'		среди уже цифр отлавливаем восьмеричные
num_error="ok"

if [[ $1 =~ $num_re ]]; then
  if [[ $1 =~ $octal_re ]]; then	если число восьмеричное, оно нас не устраивает, генерим ошибку
    num_error="$1 is not a number, did you mean ${BASH_REMATCH[1]}?"
    return 1
  fi
... и т.д.

Так вот, существует такое понятие, как match group, это (.+) в нашем octal_re='^0(.+)'
эти match group хранятся в массиве BASH_REMATCH и в данном конкретном примере:
человек передал параметр, например, 025, то нас не устраивает, т.к. нарушит всю арифметику в баше,
потому мы спрашиваем, имел ли он в виду 25 с помощью match group...
...хотя вообще, на самом деле не отработало бы для 00025, я так понимаю... надо грамотнее делать шаблон
в общем, знаем, что есть такая возможность, понадобится - ознакомимся...

END OF OPTIONS

--		это end of options, все после него не будет рассматриваться, как опция

например есть файл -aaa.txt
rm -aaa.txt		не пройдет
rm -- -aaa.txt 		все будет ок

или

for i in *.txt; do touch -- $i; done

!!! ПОЭТОМУ В СКРИПТАХ ИСПОЛЬЗУЕМ, НЕ ЗАБЫВАЕМ, ЭТО GOOD HABIT!!!

-----------------------------------------------
MANY WAYS TO RUN YOUR SCRIPT

#!				нужны x права
bash script			не нужны x права
source script или .script	import code in the current shell process
                                то есть не надо export, все быдет доступно
				пример .bashrc


! Background & nohup !

script &			отправить в  BG
  отключается от интерактивной сессии
  остановится, если потребуется ввыод с терминала

nohup script &
  сохранится при выходе из терминальной сессии
  остальное - аналогично

nohup nice script &
  длинный скрипт, с другим приоритетом в BG


! Exec !
exect >logfile 2>errorlog
Если прописать в скрипте, то можно перенаправить stdout и т.д., см пример:

+++ пример start +++

if [[ $1 = "-l" ]]; then
  exec >logfile
fi

+++ пример stop +++


! at & cron !
Использовать для запуска по расписанию.
at -f myscript noon tomorrow
cron без комментариев
launchd это в MacOS

! set & shopt !
Это не для production, для отладки только !!
set -x		при исполнении будет все подробно расписывать
set -u		выходит при попытке использовать неициализированную переменную
set -n		просто прочитать скрипт, но не исполнять
set -v		печатать команды при чтении
set -e		выход из скрипта, когда что - то внутри рушится, чтобы можно было посмотреть $?

shopt
  -s / -u    это set/unset опцию

shopt -s nocaseglob	игнорировать регистр при раскрытии путей
shopt -s extglob	extended pattern matching, не то же, что regexp !
shopt -s dotglob	включать скрытые файлы при раскрытии путей

По этому поводу - читать, когда понадобится...


-----------------------------------------------

=============================================================================
=============================================================================
РЕВЕРС АРГУМЕНТОВ

#!/bin/bash

echo "Прямой порядок: "$*
#echo "Всего аргументов: "$#


i=$#
echo -n "Обратный порядок: "

while [ "$i" -gt 0 ]; do
  echo -n ${!i}" "
  ((i--))
done
echo ""

=============================================================================
РЕАЛИЗАЦИЯ CAT

while read -r || [[ $REPLY ]]; do printf "%s\n" "$REPLY"; done < "/etc/passwd"

в тесте read -r || [[ $REPLY ]] конструкция [[ $REPLY ]] выводит последнюю строку,
т.к. по хорошему при достижениии EOF цикл вывалится до вывода последней строки...

=============================================================================
ПАЧКА ФАЙЛОВ

touch {a..h}.txt

=============================================================================
вот как работает eval:
1) foo=10 x=foo
2) y='$'$x
3) echo $y
4) $foo
5) eval y='$'$x
6) echo $y
7) 10
=============================================================================
In bash, you can use ${!i} to mean the value of the parameter whose name is $i.
This works when $i is either a named parameter or a number (denoting a positional parameter).
While you're at it, you can make use of other bash convenience features.
}

#BASH перенос строки в ECHO:
echo -e "Hello\nworld"
echo -e 'Hello\nworld'
echo Hello$'\n'world
#или через printf
printf "hello\nworld\n"

=============================================================================
cat /dev/null > file #Очистить содержимое файла
=============================================================================
#### Пример чтения строк ####
#!/bin/bash
# Чтение строк из файла /etc/fstab.

File=/etc/fstab

{
read line1
read line2
} < $File

echo "Первая строка в $File :"
echo "$line1"
echo
echo "Вторая строка в $File :"
echo "$line2"

exit 0

=============================================================================
\( … \)
https://www.gnu.org/software/emacs/manual/html_node/emacs/Regexp-Backslash.html
=============================================================================

\( … \) is a grouping construct that serves three purposes:

1. To enclose a set of ‘\|’ alternatives for other operations.
   Thus, ‘\(foo\|bar\)x’ matches either ‘foox’ or ‘barx’.
2. To enclose a complicated expression for the postfix operators ‘*’, ‘+’ and ‘?’ to operate on.
   Thus, ‘ba\(na\)*’ matches ‘bananana’, etc., with any (zero or more) number of ‘na’ strings.
3. To record a matched substring for future reference.
   This last application is not a consequence of the idea of a parenthetical grouping;
   it is a separate feature that is assigned as a second meaning to the same ‘\( … \)’ construct.
   In practice there is usually no conflict between the two meanings; when there is a conflict,
   you can use a “shy” group.


=============================================================================
=============================================================================